

import numpy as np
import scipy
import matplotlib.pyplot as plt
import os
import pickle
from pypeit.core import load, flux_calib
from pypeit.core.wavecal import wvutils
from astropy import table
from pypeit.core import save
from pypeit.core import coadd
from pypeit import specobjs
from pypeit import utils
from pypeit import msgs
from astropy.io import fits
from sklearn import mixture
from pypeit.core import telluric

from IPython import embed
from pypeit.spectrographs.util import load_spectrograph

# User defined functions
# obj_dict, bounds_obj = init_obj_model(obj_params, iord, wave, flux, ivar, mask, tellmodel)
# obj_model, modelmask =  eval_obj_model(theta_obj, obj_dict)

class Telluric(object):
    """
    This class performs a joint fit of a spectrum with a model describing the object spectrum, and a model
    of the telluric absorption from the atmosphere. The latter are generated by HITRAN atmosphere models with
    generated with a baseline atmospheric profile model of the observatory in question. It works on multislit
    data or echelle data. The code performs a differential evolution optimization using
    scipy.optimize.differential_evolution. Several iterations are performed with rejection of outliers
    (governed by the maxiter parameter below). In general it produces very good results, but is rather slow. Progress
    can be monitored using the disp=True option, which will print out the progress to the screen. This will look like:

       differential_evolution step 101: f(x)= 105392

    Here f(x) represents the value of the loss function, which is essentially the chi^2 (but with the non-Gaussian
    tails remapped, and outliers rejected). Things are going well if the result of differential evolution yields
    a value of f(x) comparable to the number of pixels in your spectrum (or in the order in question for echelle data),
    which are the number of degrees of freedom. If debug=True, it will show the residuals from the fit at each iteration.
    Note that for spectra with S/N > 30, the residual distribubtion may look narrower because a floor is added to the
    noise (see sn_clip documentation below) to prevent excessive rejection and poorly behaved fits. Basically these
    telluric models are only good to about 3%, and so we cannot fit the data within the noise better than that,
    which is why sn_clip is implemented.

    The object model is specified by the user through two user provided functions init_obj_model and eval_obj_model,
    as described below. The init_obj_model function is required because differential_evolution can only perform bounded
    optimization. The bounds for the telluric are set by the grid and initialized without user involvement. But for the
    object model, the bounds depend on the nature of the object model, which is why init_obj_model must be provided.

    The telluric model is governed by six parameters:

        pressure, temperature, humidity, airmass, resln, shift

    Where resln is the resolution of the spectrograph and shift is a shift in pixels. The airmass of the object
    will be used to initalize the fit (this helps with initalizing the object model), but the models are sufficiently
    flexible that often the best fit airmass actually differs from the airmass of the spectrum.

    This code can be run on stacked spectra covering a large range of airmasses and will still provide good results.
    The resulting airmass will be an effective value, and as per above may not have much relation to the true airmass
    of the observation. The exception to this rule is extremely high signal-to-noise ratio data S/N > 30, for which it
    can be difficult to obtain a good fit within the noise of the data. In such cases, the user should split up the data
    into chunks taken around the same airmass, fit those individually with this class, and then combine the resulting
    telluric corrected spectra (not done by this class).  This will in general result in better fits, and will also
    average down the residuals from the telluric model fit in the final averaged spectrum.

    Args:
        wave (np.ndarray):
            Wavelength array. Must either have shape (nspec,) or (nspec, norders), the latter being for echelle data.
        flux (np.ndarray):
            Flux for the object in question. Same shape as wave.
        ivar (np.ndarray):
            Inverse variance for the object in question. Same shape as wave.
        mask (np.ndarray):
            Good pixel mask for the object in question. Same shape as wave.
        telgridfile (str):
            File containing grid of HITRAN atmosphere models. This file is given by spectrograph.telluric_grid_file
        obj_params (dict):
            Dictionary of parameters for initializing the object model.
        init_obj_model (callable):
            User defined function for initializing the object model. This function must follow the calling sequence:

              obj_dict, bounds_obj = init_obj_model(obj_params, iord, wave, flux, ivar, mask, tellmodel)

            See for example the documentation for init_star_model above for a detailed explanation of these paramaters
            and return values.
        eval_obj_model (callable):
            User defined function for evaluating the object model at a set of parameter values theta_obj. This function
            must follow the calling sequence:

            obj_model, modelmask =  eval_obj_model(theta_obj, obj_dict)

            Where obj_dict is one of the return values from the init_obj_model above. See eval_star_model above for a
            detailed explanation of these paramaters and return values.
        ech_orders (ndarray, int):
            If passed the echelle orders will be added to the meta_table. ech_orders must be a numpy array of integers
            with the shape (norders,) giving the order numbers
        sn_clip (float): default = 30.0
            This adds an error floor to the ivar, preventing too much rejection at high-S/N (i.e. standard stars,
            bright objects) using the function utils.clip_ivar. A small erorr is added to the input ivar so that the
            output ivar_out will never give S/N greater than sn_clip. This prevents overly aggressive rejection in high
            S/N ratio spectra which neverthless differ at a level greater than the formal S/N due to the fact
            that our telluric models are only good to about 3%.
        airmass_guess (float): default = 1.5
            A guess for the airmass of your object. The code fits the airmass as part of the telluric model, but this
            initial guess is useful for initializing the object model to determine the bounds for the object model
            parameter optimization via init_obj_model, since typically that is done by dividing out a guess for the
            telluric absorption and then performing some kind of intial fit.
        resln_guess (float): default = None
            A guess for the resolution of your spectrum expressed as lambda/dlambda. The resolution is fit explicitly
            as part of the telluric model fitting, but this guess helps determine the bounds for the optimization (see next).
            If not provided, the  wavelength sampling of your spectrum will be used and the resolution calculated using a typical sampling
            of 3 spectral pixels per resolution element.
        resln_frac_bounds (tuple of floats): default = (0.5,1.5)
            Bounds for the resolution fit optimization which is part of the telluric model. This range is in units of
            the resln_guess, so the (0.5, 1.5) would bound the spectral resolution fit to be within the range
            bounds_resln = (0.5*resln_guess, 1.5*resln_guess)
        pix_shift_bounds (tuple of floats): default = (-5.0, 5.0)
            Bounds for the pixel shift optimization in telluric model fit in units of pixels. The atmosphere
            will be allowed to shift within this range during the fit.
        maxiter (int): default = 3
            Maximum number of iterations for the telluric + object model fitting. The code performs multiple
            iterations rejecting outliers at each step. The fit is then performed anew to the remaining good pixels.
            For this reason if you run with the disp=True option, you will see that the f(x) loss function gets
            progressively better during the iterations.
        sticky (bool): default=True
            Sticky parameter for the utils.djs_reject algorithm for iterative model fit rejection.  If set to True then
            points rejected from a previous iteration are kept rejected, in other words the bad pixel mask is the OR
            of all previous iterations and rejected pixels accumulate. If set to False, the bad pixel mask is the mask
            from the previous iteration, and if the model  fit changes between iterations, points can alternate from being
            rejected to not rejected. At present this code only performs optimizations with differential evolution and
            experience shows that sticky needs to be True in order for these to converge. This is because the outliers can
            be so large that they dominate the loss function, and one never iteratively converges to a good model fit. In
            other words, the deformations in the model between iterations with sticky=False are too small to approach
            a reasonable fit.
        lower (float): default = 3.0
            Lower rejection threshold in units of sigma_corr*sigma, where sigma is the formal noise of the spectrum, and
            sigma_corr is an empirically determined correction to the formal error. The distribution of input chi
            (defined by chi = (data - model)/sigma) values is analyzed, and a correction factor to the formal error
            sigma_corr is returned which is multiplied into the formal errors. In this way, a rejection threshold of i.e.
            3-sigma, will always correspond to roughly the same percentile.  This renormalization is performed with
            coadd1d.renormalize_errors function, and guarantees that rejection is not too agressive in cases where the
            empirical errors determined from the chi-distribution differ significantly from the formal noise which is
            used to determine chi.
        upper (float): upper = 3.0
            Upper rejection threshold in units of sigma_corr*sigma, where sigma is the formal noise of the spectrum, and
            sigma_corr is an empirically determined correction to the formal error. See above for description.
        seed (int): default = 777
            An initial seed for the differential evolution optimization, which is a random process. The default is
            a seed = 777 which will be used to generate a unique seed for every order. A specific seed is used
            because otherwise the random number generator will use the time for the seed, and the results will not
            be reproducible.
        tol (float): default = 1e-3
            Relative tolerance for converage of the differential evolution optimization. See
            scipy.optimize.differential_evolution for details.
        popsize (int): default = 30
            A multiplier for setting the total population size for the differential evolution optimization. See
            scipy.optimize.differential_evolution for details.
        recombination (float): default = 0.7
            The recombination constant for the differential evolution optimization. This should be in the range [0, 1].
            See scipy.optimize.differential_evolution for details.
        polish (bool): default=True
            If True then differential evolution will perform an additional optimizatino at the end to polish the best fit
            at the end, which can improve the optimization slightly. See scipy.optimize.differential_evolution for details.
        disp (bool): default=True
            Argument for scipy.optimize.differential_evolution which will  display status messages to the screen
            indicating the status of the optimization. See above for a description of the output and how to know
            if things are working well.
        debug (bool): default=False
            If True, QA plots will be shown to the screen indicating the quality of the fits. Specifically, the residual
            distributions will be shown at each iteration, and the fit will be shown at the end (for each order).
            This is useful if you are running the code for the first time, but since the algorithm is slow, particularly
            for fitting multi-order echelle data, it will require lots of clicking to close interactive matplotlib windows
            which block execution.
    """
    def __init__(self, wave, flux, ivar, mask, telgridfile, obj_params, init_obj_model, eval_obj_model,
                 ech_orders=None,
                 sn_clip=30.0, airmass_guess=1.5, resln_guess=None,
                 resln_frac_bounds=(0.5, 1.5), pix_shift_bounds=(-5.0, 5.0),
                 maxiter=3, sticky=True, lower=3.0, upper=3.0,
                 seed=777, tol=1e-3, popsize=30, recombination=0.7, polish=True, disp=True, debug=False):

        # This init function performs the following steps:
        # 1) assignement of relevant input arguments
        # 2) reshape all spectra to be shape (nspec, norders) which the code operates on
        # 3) read in and initalize the telluric grid
        # 4) Interpolate spectra onto the fixed telluric wavelength grid, clip S/N
        # 5) Loop over orders to initialize object models, and determine index range of fits
        # 6) Initalize the output tables

        # 1) Assign arguments
        self.telgridfile = telgridfile
        self.obj_params = obj_params
        self.init_obj_model = init_obj_model
        self.airmass_guess = airmass_guess
        self.eval_obj_model = eval_obj_model
        self.ech_orders = ech_orders
        self.sn_clip = sn_clip
        self.resln_frac_bounds = resln_frac_bounds
        self.pix_shift_bounds = pix_shift_bounds
        self.maxiter = maxiter
        self.sticky = sticky
        self.lower = lower
        self.upper = upper
        self.tol = tol
        self.popsize = popsize
        self.recombination = recombination
        self.polish = polish
        self.disp = disp
        self.debug = debug

        # 2) Reshape all spectra to be (nspec, norders)
        self.wave_in_arr, self.flux_in_arr, self.ivar_in_arr, self.mask_in_arr, self.nspec_in, self.norders = \
            utils.spec_atleast_2d(wave, flux, ivar, mask)

        # Optimizer requires a seed. This guarantees that the fit will be deterministic and hence reproducible
        self.seed = seed
        rand = np.random.RandomState(seed=self.seed)
        seed_vec = rand.randint(2 ** 32 - 1, size=self.norders)

        # 3) Read the telluric grid and initalize associated parameters
        self.tell_dict = self.read_telluric_grid()
        self.wave_grid = self.tell_dict['wave_grid']
        self.ngrid = self.wave_grid.size
        self.resln_guess = wvutils.get_sampling(self.wave_in_arr)[2] if resln_guess is None else resln_guess
        # Model parameter guess for determining the bounds with the init_obj_model function
        self.tell_guess = self.get_tell_guess()
        # Set the bounds for the telluric optimization
        self.bounds_tell = self.get_bounds_tell()

        # 4) Interpolate the input values onto the fixed telluric wavelength grid, clip S/N and process inmask
        self.flux_arr, self.ivar_arr, self.mask_arr = coadd.interp_spec(self.wave_grid, self.wave_in_arr, self.flux_in_arr,
                                                                        self.ivar_in_arr, self.mask_in_arr)
        # This is a hack to get an interpolate mask indicating where wavelengths are good on each order
        _, _, self.wave_mask_arr = coadd.interp_spec(
            self.wave_grid, self.wave_in_arr, np.ones_like(self.flux_in_arr), np.ones_like(self.ivar_in_arr),
            (self.wave_in_arr > 1.0).astype(float))
        # Clip the ivar if that is requested (sn_clip = None simply returns the ivar otherwise)
        self.ivar_arr = utils.clip_ivar(self.flux_arr, self.ivar_arr, self.sn_clip, mask=self.mask_arr)

        # 5) Loop over orders to initialize object models, and determine index range of fits
        # sort the orders by the strength of their telluric absorption
        self.ind_lower, self.ind_upper = self.get_ind_lower_upper()
        self.srt_order_tell = self.sort_telluric()
        # Loop over the data to:
        #     1) determine the ind_lower, ind_upper for every order/spectrum
        #     2) initialize the obj_dict, and bounds by running the init_obj_model callable
        self.obj_dict_list = [None]*self.norders
        self.bounds_obj_list = [None]*self.norders
        self.bounds_list = [None]*self.norders
        self.arg_dict_list = [None]*self.norders
        self.max_ntheta_obj = 0
        for counter, iord in enumerate(self.srt_order_tell):
            msgs.info('Initializing object model for order: {:d}, {:d}/{:d}'.format(iord, counter, self.norders) +
                      ' with user supplied function: {:s}'.format(self.init_obj_model.__name__))
            tellmodel = telluric.eval_telluric(self.tell_guess, self.tell_dict,
                                      ind_lower=self.ind_lower[iord], ind_upper=self.ind_upper[iord])
            obj_dict, bounds_obj = init_obj_model(obj_params, iord,
                                                  self.wave_grid[self.ind_lower[iord]:self.ind_upper[iord]+1],
                                                  self.flux_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord],
                                                  self.ivar_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord],
                                                  self.mask_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord],
                                                  tellmodel)
            self.obj_dict_list[iord] = obj_dict
            self.bounds_obj_list[iord] = bounds_obj
            self.max_ntheta_obj = np.fmax(self.max_ntheta_obj, len(bounds_obj))
            bounds_iord = bounds_obj + self.bounds_tell
            self.bounds_list[iord] = bounds_iord
            arg_dict_iord = dict(ivar=self.ivar_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord],
                                 tell_dict=self.tell_dict, ind_lower=self.ind_lower[iord], ind_upper=self.ind_upper[iord],
                                 obj_model_func=self.eval_obj_model, obj_dict=obj_dict,
                                 bounds=bounds_iord, seed=seed_vec[iord], debug=debug)
            self.arg_dict_list[iord] = arg_dict_iord

        # 6) Initalize the output tables
        self.meta_table, self.out_table = self.init_output()

    def run(self, only_orders=None):
        """
        Loops over orders/slits, runs the telluric correction, and evaluates the object and telluric models.

        Parameters
        ----------
        only_orders

        Returns
        -------

        """

        only_orders = [only_orders] if (only_orders is not None and
                                        isinstance(only_orders, (int, np.int, np.int64, np.int32))) else only_orders
        good_orders = self.srt_order_tell if only_orders is None else only_orders
        # Run the fits
        self.result_list = [None]*self.norders
        self.outmask_list = [None]*self.norders
        self.obj_model_list = [None]*self.norders
        self.tellmodel_list = [None]*self.norders
        self.theta_obj_list = [None]*self.norders
        self.theta_tell_list = [None]*self.norders
        for counter, iord in enumerate(self.srt_order_tell):
            if iord not in good_orders:
                continue
            msgs.info('Fitting object + telluric model for order: {:d}, {:d}/{:d}'.format(iord, counter, self.norders) +
                      ' with user supplied function: {:s}'.format(self.init_obj_model.__name__))
            self.result_list[iord], ymodel, ivartot, self.outmask_list[iord] = utils.robust_optimize(
                self.flux_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord], tellfit, self.arg_dict_list[iord],
                inmask=self.mask_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord],
                maxiter=self.maxiter, lower=self.lower, upper=self.upper, sticky=self.sticky,
                tol=self.tol, popsize=self.popsize, recombination=self.recombination, polish=self.polish, disp=self.disp)
            self.theta_obj_list[iord] = self.result_list[iord].x[:-6]
            self.theta_tell_list[iord] = self.result_list[iord].x[-6:]
            self.obj_model_list[iord], modelmask = self.eval_obj_model(self.theta_obj_list[iord], self.obj_dict_list[iord])
            self.tellmodel_list[iord] = telluric.eval_telluric(self.theta_tell_list[iord], self.tell_dict,
                                                      ind_lower=self.ind_lower[iord],
                                                      ind_upper=self.ind_upper[iord])
            self.assign_output(iord)
            if self.debug:
                self.show_fit_qa(iord)

    def save(self, outfile):
        """
        Method for writing astropy tables containing the telluric and object model fits to a multi-extension fits file

        Args:
            outfile:

        Returns:

        """
        # Write to outfile
        msgs.info('Writing object and telluric models to file: {:}'.format(outfile))
        hdu_meta = fits.table_to_hdu(self.meta_table)
        hdu_meta.name = 'METADATA'
        hdu_out = fits.table_to_hdu(self.out_table)
        hdu_out.name = 'OUT_TABLE'
        hdulist = fits.HDUList()
        hdulist.append(hdu_meta)
        hdulist.append(hdu_out)
        hdulist.writeto(outfile, overwrite=True)

    def load(self, tellfile):
        """
        Method for reading telluric and object models fits from a multi-extension fits file

        Args:
            outfile:

        Returns:

        """
        # Write to outfile
        msgs.info('Reading object and telluric models from file: {:}'.format(tellfile))
        meta_table = table.Table.read(tellfile, hdu=1)
        out_table = table.Table.read(tellfile, hdu=2)

        return meta_table, out_table

    def show_fit_qa(self, iord):
        """
        Generates QA plot for telluric fitting

        Args:
            iord: the order being currently fit

        """

        wave_now = self.wave_grid[self.ind_lower[iord]:self.ind_upper[iord]+1]
        flux_now = self.flux_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord]
        sig_now = np.sqrt(utils.inverse(self.ivar_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord]))
        mask_now = self.mask_arr[self.ind_lower[iord]:self.ind_upper[iord]+1, iord]
        model_now = self.tellmodel_list[iord]*self.obj_model_list[iord]
        rejmask = mask_now & np.invert(self.outmask_list[iord])

        fig = plt.figure(figsize=(12, 8))
        plt.plot(wave_now, flux_now, drawstyle='steps-mid',
                 color='k', label='data', alpha=0.7, zorder=5)
        plt.plot(wave_now, sig_now, drawstyle='steps-mid', color='0.7', label='noise', alpha=0.7, zorder=1)
        plt.plot(wave_now, model_now, drawstyle='steps-mid', color='red', linewidth=1.0, label='model',
                 zorder=7, alpha=0.7)
        plt.plot(wave_now[rejmask], flux_now[rejmask], 's', zorder=10, mfc='None', mec='blue', label='rejected pixels')
        plt.plot(wave_now[np.invert(mask_now)], flux_now[np.invert(mask_now)], 'v', zorder=9, mfc='None', mec='orange',
                 label='originally masked')
        plt.ylim(-0.1 * model_now.max(), 1.3 * model_now.max())
        plt.legend()
        plt.xlabel('Wavelength')
        plt.ylabel('Flux or Counts')
        plt.title('QA plot for order: {:d}/{:d}'.format(iord, self.norders))
        plt.show()

    def init_output(self):
        """
        Method to initialize the outputs

        Returns:
            tuple: Returns two `astropy.table.Table`_ objects:
                - meta_table: Table containing the meta information for
                  the telluric model fits
                - out_table: Table containing the telluric model fits
                  and the object model fits.
        """

        # Allocate the meta parameter table, ext=1
        meta_table = table.Table(meta={'name': 'Parameter Values'})
        meta_table['TOL'] = [self.tol]
        meta_table['POPSIZE'] = [self.popsize]
        meta_table['RECOMBINATION'] = [self.recombination]
        meta_table['TELGRIDFILE'] = [os.path.basename(self.telgridfile)]
        if 'output_meta_keys' in self.obj_params:
            for key in self.obj_params['output_meta_keys']:
                meta_table[key.upper()] = [self.obj_params[key]]
        if self.ech_orders is not None:
            meta_table['ECH_ORDERS'] = [self.ech_orders]

        # Allocate the output table, ext=2
        out_table = table.Table(meta={'name': 'Object Model and Telluric Correction'})
        out_table['WAVE'] = np.zeros((self.norders, self.nspec_in))
        out_table['TELLURIC'] = np.zeros((self.norders, self.nspec_in))
        out_table['OBJ_MODEL'] = np.zeros((self.norders, self.nspec_in))
        out_table['TELL_THETA'] = np.zeros((self.norders, 6))
        out_table['TELL_PRESS'] = np.zeros(self.norders)
        out_table['TELL_TEMP'] = np.zeros(self.norders)
        out_table['TELL_H2O'] = np.zeros(self.norders)
        out_table['TELL_AIRMASS'] = np.zeros(self.norders)
        out_table['TELL_RESLN'] = np.zeros(self.norders)
        out_table['TELL_SHIFT'] = np.zeros(self.norders)
        out_table['OBJ_THETA'] = np.zeros((self.norders, self.max_ntheta_obj))
        out_table['CHI2'] = np.zeros(self.norders)
        out_table['SUCCESS'] = np.zeros(self.norders, dtype=bool)
        out_table['NITER'] = np.zeros(self.norders, dtype=int)
        out_table['IND_LOWER'] = self.ind_lower
        out_table['IND_UPPER'] = self.ind_upper
        out_table['WAVE_MIN'] = self.wave_grid[self.ind_lower]
        out_table['WAVE_MAX'] = self.wave_grid[self.ind_upper]


        return meta_table, out_table


    def assign_output(self, iord):
        """
        Routine to assign outputs to self.out_table for the order in question.

        Args:
            iord (int):
            The order for which the output table should bbe assigned.


        """

        ## TODO Store the outmask with rejected pixels??
        gdwave = self.wave_in_arr[:,iord] > 1.0
        wave_in_gd = self.wave_in_arr[gdwave,iord]
        wave_grid_now = self.wave_grid[self.ind_lower[iord]:self.ind_upper[iord]+1]
        self.out_table['WAVE'][iord] = self.wave_in_arr[:,iord]
        self.out_table['TELLURIC'][iord][gdwave] = scipy.interpolate.interp1d(
            wave_grid_now, self.tellmodel_list[iord], kind='linear', bounds_error=False, fill_value=0.0)(wave_in_gd)
        self.out_table['OBJ_MODEL'][iord][gdwave] = scipy.interpolate.interp1d(
            wave_grid_now, self.obj_model_list[iord], kind='linear', bounds_error=False, fill_value=0.0)(wave_in_gd)
        self.out_table['TELL_THETA'][iord] = self.theta_tell_list[iord]
        self.out_table['TELL_PRESS'][iord] = self.theta_tell_list[iord][0]
        self.out_table['TELL_TEMP'][iord] = self.theta_tell_list[iord][1]
        self.out_table['TELL_H2O'][iord] = self.theta_tell_list[iord][2]
        self.out_table['TELL_AIRMASS'][iord] = self.theta_tell_list[iord][3]
        self.out_table['TELL_RESLN'][iord] = self.theta_tell_list[iord][4]
        self.out_table['TELL_SHIFT'][iord] = self.theta_tell_list[iord][5]
        ntheta_iord = len(self.theta_obj_list[iord])
        self.out_table['OBJ_THETA'][iord][0:ntheta_iord+1] = self.theta_obj_list[iord]
        self.out_table['CHI2'][iord] = self.result_list[iord].fun
        self.out_table['SUCCESS'][iord] = self.result_list[iord].success
        self.out_table['NITER'][iord] = self.result_list[iord].nit

    # TODO Purge? This does not appear to be used at the moment.
    def interpolate_inmask(self, mask, wave_inmask, inmask):
        """
        Utitlity routine to interpolate the input mask.
        """

        if inmask is not None:
            if wave_inmask is None:
                msgs.error('If you are specifying a mask you need to pass in the corresponding wavelength grid')
            # TODO we shoudld consider refactoring the interpolator to take a list of images and masks to remove the
            # the fake zero images in the call below
            _, _, inmask_int = coadd.interp_spec(self.wave_grid, wave_inmask, np.ones_like(wave_inmask),
                                                 np.ones_like(wave_inmask), inmask)
            # If the data mask is 2d, and inmask is 1d, tile to create the inmask aligned with the data
            if mask.ndim == 2 & inmask.ndim == 1:
                inmask_out = np.tile(inmask_int, (self.norders, 1)).T
            # If the data mask and inmask have the same dimensionlaity, interpolated mask has correct dimensions
            elif mask.ndim == inmask.ndim:
                inmask_out = inmask_int
            else:
                msgs.error('Unrecognized shape for data mask')
            return (mask & inmask_out)
        else:
            return mask


    def get_ind_lower_upper(self):
        """
        Utiltity routine to determine the ind_lower and ind_upper for each order. This trimming makes things
        faster because then we only need to convolve the portion of the telluric model that is needed for the model fit
        to each order, rather than convolving the entire telluric model grid.

        Returns:
            ind_lower, ind_upper

            ind_lower (int):
               Lower index into the telluric model wave_grid to trim down the telluric model.
            ind_upper (int):
               Upper index into the telluric model wave_grid to trim down the telluric model.

        """

        ind_lower = np.zeros(self.norders, dtype=int)
        ind_upper = np.zeros(self.norders, dtype=int)
        for iord in range(self.norders):
            # This presumes that the data has been interpolated onto the telluric model grid
            wave_grid_ma = np.ma.array(np.copy(self.wave_grid))
            # For the ind lower and upper, use the good wavelength mask, not the data mask. This gives
            # us the model everywhere where wavelengths are not zero
            wave_grid_ma.mask = np.invert(self.wave_mask_arr[:, iord])
            #wave_grid_ma.mask = np.invert(self.mask_arr[:,iord])
            ind_lower[iord] = np.ma.argmin(wave_grid_ma)
            ind_upper[iord] = np.ma.argmax(wave_grid_ma)
        return ind_lower, ind_upper

    ##########################
    ## telluric grid methods #
    ##########################
    def read_telluric_grid(self, wave_min=None, wave_max=None, pad=0):
        """
        Wrapper for utility function read_telluric_grid
        Args:
            wave_min:
            wave_max:
            pad:

        Returns:

        """

        return telluric.read_telluric_grid(self.telgridfile, wave_min=wave_min, wave_max=wave_max, pad=pad)


    def get_tell_guess(self):
        """
        Utility routine to get the telluric guess to determine the bounds with the init_obj_model function.
        """

        tell_guess = (np.median(self.tell_dict['pressure_grid']),
                      np.median(self.tell_dict['temp_grid']),
                      np.median(self.tell_dict['h2o_grid']),
                      self.airmass_guess, self.resln_guess, 0.0)

        return tell_guess

    def get_bounds_tell(self):
        """
        Utility routine to determine the telluric model grid bounds for the optimization.

        """

        # Set the bounds for the optimization
        bounds_tell = [(self.tell_dict['pressure_grid'].min(), self.tell_dict['pressure_grid'].max()),
                       (self.tell_dict['temp_grid'].min(), self.tell_dict['temp_grid'].max()),
                       (self.tell_dict['h2o_grid'].min(), self.tell_dict['h2o_grid'].max()),
                       (self.tell_dict['airmass_grid'].min(), self.tell_dict['airmass_grid'].max()),
                       (self.resln_guess * self.resln_frac_bounds[0], self.resln_guess * self.resln_frac_bounds[1]),
                       self.pix_shift_bounds]

        return bounds_tell

    def sort_telluric(self):
        """
        Utility routine to determine the order in which the telluric model is fit for multi-order data. This is done
        by computing the median telluric absorption at the midpoint of parameters governing the telluric grid, for the
        given the wavelengths of the data set by the ind_lower, ind_upper.

        Args:

        Returns:
            srt_order_tell (`numpy.ndarray`_, int):
                Array of sorted indices from strongest telluric absorption to weakest.
        """

        tell_med = np.zeros(self.norders)
        # Do a quick loop over all the orders to sort them in order of strongest to weakest telluric absorption
        for iord in range(self.norders):
            tm_grid = self.tell_dict['tell_grid'][:, :, :, :, self.ind_lower[iord]:self.ind_upper[iord] + 1]
            tell_model_mid = tm_grid[tm_grid.shape[0] // 2, tm_grid.shape[1] // 2, tm_grid.shape[2] // 2,
                             tm_grid.shape[3] // 2, :]
            tell_med[iord] = np.mean(tell_model_mid)

        # Perform fits in order of telluric strength
        srt_order_tell = tell_med.argsort()

        return srt_order_tell

